# Internal-API-Starter 链路追踪增强

## 概述

为 `internal-api-starter` 模块增强了链路追踪能力，实现了分布式调用链的自动传播和记录。

## 增强内容

### 1. 新增依赖

在 `pom.xml` 中添加了 `trace-starter` 依赖：

```xml
<dependency>
    <groupId>com.qbit.framework</groupId>
    <artifactId>trace-starter</artifactId>
    <version>${project.version}</version>
</dependency>
```

### 2. 新增组件

#### FeignTraceInterceptor（链路追踪拦截器）

**位置**: `com.qbit.framework.starter.merchant.interceptor.FeignTraceInterceptor`

**功能**:
- 自动从 MDC 中获取当前线程的 `traceId` 和 `spanId`
- 将 `traceId` 通过 `X-Trace-Id` 请求头传递到下游服务
- 为下游服务生成新的 `spanId`，通过 `X-Span-Id` 请求头传递
- 在 DEBUG 日志级别下记录链路追踪信息

**代码示例**:
```java
@Override
public void apply(RequestTemplate template) {
    String traceId = TraceUtils.get(TraceUtils.TRACE_ID);
    String spanId = TraceUtils.get(TraceUtils.SPAN_ID);

    if (traceId != null && !traceId.isBlank()) {
        template.header(TraceUtils.TRACE_ID_HEADER, traceId);
        log.debug("Feign request trace propagation: traceId={}", traceId);
    }

    if (spanId != null && !spanId.isBlank()) {
        // 为下游服务生成新的 spanId，保持 traceId 不变
        String newSpanId = TraceUtils.newId();
        template.header(TraceUtils.SPAN_ID_HEADER, newSpanId);
        log.debug("Feign request trace propagation: spanId={} (new spanId for downstream: {})", spanId, newSpanId);
    }
}
```

**常量定义**:

所有链路追踪相关的常量都统一定义在 `TraceUtils` 中：

```java
// trace-starter/src/main/java/com/qbit/framework/starter/trace/TraceUtils.java
public final class TraceUtils {
    // MDC 中的 key
    public static final String TRACE_ID = "traceId";
    public static final String SPAN_ID = "spanId";

    // HTTP 请求头名称
    public static final String TRACE_ID_HEADER = "X-Trace-Id";
    public static final String SPAN_ID_HEADER = "X-Span-Id";
    
    // ... 其他方法
}
```

这样做的好处：
- ✅ **统一管理** - 避免在多个地方重复定义常量
- ✅ **保持一致性** - 确保所有模块使用相同的请求头名称
- ✅ **便于维护** - 如果需要修改，只需改一处

### 3. InternalRequestInterceptor（签名拦截器）

**职责**: 为请求添加签名相关的请求头

**设计原则**: 保持职责单一，只负责签名功能，不添加日志等其他功能

**功能**:
- GET 请求：添加 `sign` 查询参数
- POST/PUT/DELETE 请求：添加 `x-sign`、`x-nonce-str`、`x-timestamp` 请求头

**说明**:
- HTTP 请求/响应的日志由 `SingleLineHttpLogger` 负责（在 `FeignAutoConfiguration` 中配置）
- 链路追踪的传播由 `FeignTraceInterceptor` 负责
- 签名拦截器专注于签名功能，保持职责单一

### 4. 自动配置

在 `FeignAutoConfiguration` 中添加了链路追踪拦截器的自动配置：

```java
@Bean
@ConditionalOnMissingBean(name = "feignTraceInterceptor")
@ConditionalOnClass(name = "com.qbit.framework.starter.trace.TraceUtils")
public RequestInterceptor feignTraceInterceptor() {
    return new FeignTraceInterceptor();
}
```

**特点**:
- 自动检测 `trace-starter` 是否存在
- 如果存在，自动注册链路追踪拦截器
- 支持用户自定义覆盖（通过 `@ConditionalOnMissingBean`）

## 使用方式

### 1. 基本使用

无需额外配置，只要项目中引入了 `internal-api-starter`，链路追踪功能就会自动启用。

```java
@Service
public class OrderService {
    @Autowired
    private UserFeignClient userFeignClient;  // Feign 客户端
    
    public void createOrder(Long userId) {
        // 调用下游服务时，traceId 和 spanId 会自动传递
        User user = userFeignClient.getUserById(userId);
        // ...
    }
}
```

### 2. 启用 DEBUG 日志

在 `application.yml` 中配置日志级别：

```yaml
logging:
  level:
    com.qbit.framework.starter.merchant.interceptor: DEBUG
```

启用后可以看到链路追踪日志：

```
DEBUG - Feign request trace propagation: traceId=550e8400-e29b-41d4-a716-446655440000
DEBUG - Feign request trace propagation: spanId=660e8400-e29b-41d4-a716-446655440001 (new spanId for downstream: 770e8400-e29b-41d4-a716-446655440002)
DEBUG - Internal API request [traceId=550e8400-e29b-41d4-a716-446655440000]: POST /api/users - signature headers added (timestamp=1701234567890, nonceStr=abc123)
```

### 3. 与 trace-starter 配合使用

如果项目中同时使用了 `trace-starter`，可以实现完整的链路追踪：

```yaml
# application.yml
trace:
  enabled: true
  web-enabled: true  # 启用 Web 拦截器，自动为每个请求生成 traceId
```

**完整调用链示例**:

```
1. 用户请求 -> API Gateway (traceId: A, spanId: A1)
   ↓
2. Gateway -> Service A (traceId: A, spanId: A2)  [trace-starter 自动生成]
   ↓
3. Service A -> Service B (traceId: A, spanId: A3)  [FeignTraceInterceptor 自动传递]
   ↓
4. Service B -> Service C (traceId: A, spanId: A4)  [FeignTraceInterceptor 自动传递]
```

## 工作原理

### 链路追踪传播流程

```
┌─────────────────────────────────────────────────────────────┐
│  Service A (上游服务)                                        │
│                                                              │
│  1. TraceInterceptor 从请求头提取 traceId/spanId             │
│     └─> 存储到 MDC                                           │
│                                                              │
│  2. 业务代码执行                                              │
│     └─> 调用 Feign Client                                    │
│                                                              │
│  3. FeignTraceInterceptor 拦截                               │
│     ├─> 从 MDC 获取 traceId (保持不变)                       │
│     ├─> 生成新的 spanId                                      │
│     └─> 添加到请求头: X-Trace-Id, X-Span-Id                 │
│                                                              │
│  4. InternalRequestInterceptor 拦截                          │
│     ├─> 添加签名头: x-sign, x-nonce-str, x-timestamp        │
│     └─> 记录日志 (包含 traceId)                              │
│                                                              │
└──────────────────────┬───────────────────────────────────────┘
                       │ HTTP Request
                       │ Headers:
                       │   X-Trace-Id: A
                       │   X-Span-Id: A3
                       │   x-sign: xxx
                       │   x-timestamp: 1701234567890
                       ↓
┌─────────────────────────────────────────────────────────────┐
│  Service B (下游服务)                                        │
│                                                              │
│  1. TraceInterceptor 从请求头提取 traceId/spanId             │
│     └─> 存储到 MDC (traceId: A, spanId: A3)                 │
│                                                              │
│  2. 业务代码执行 (可以继续调用其他服务)                       │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 拦截器执行顺序

Feign 的多个 `RequestInterceptor` 会按照注册顺序执行：

1. **FeignTraceInterceptor** - 添加链路追踪头
2. **InternalRequestInterceptor** - 添加签名头并记录日志

两个拦截器互不干扰，各司其职。

## 优势

### 1. **零侵入**
- 业务代码无需修改
- 自动从 MDC 获取和传递链路信息
- 自动注册和配置

### 2. **完整的调用链**
- 保持 `traceId` 在整个调用链中不变
- 为每个服务调用生成新的 `spanId`
- 支持多级服务调用

### 3. **易于调试**
- DEBUG 日志记录详细的链路信息
- 签名拦截器也记录 `traceId`
- 便于问题排查和性能分析

### 4. **灵活配置**
- 支持条件装配（检测 `trace-starter` 是否存在）
- 支持用户自定义覆盖
- 可以通过日志级别控制输出

## 最佳实践

### 1. 统一使用 trace-starter

建议在所有微服务中都引入 `trace-starter`：

```xml
<dependency>
    <groupId>com.qbit.framework</groupId>
    <artifactId>trace-starter</artifactId>
</dependency>
```

### 2. 配置统一的日志格式

在 `logback-spring.xml` 中添加 `traceId` 和 `spanId`：

```xml
<pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] [%X{traceId}] [%X{spanId}] %-5level %logger{36} - %msg%n</pattern>
```

### 3. 集成 APM 工具

可以将 `traceId` 和 `spanId` 上报到 APM 工具（如 SkyWalking、Zipkin）：

```java
@Component
public class ApmTraceReporter {
    @EventListener
    public void onRequest(RequestEvent event) {
        String traceId = TraceUtils.get(TraceUtils.TRACE_ID);
        String spanId = TraceUtils.get(TraceUtils.SPAN_ID);
        // 上报到 APM
        apmClient.reportSpan(traceId, spanId, event);
    }
}
```

### 4. 监控告警

基于 `traceId` 实现：
- 慢查询告警（同一个 traceId 的总耗时）
- 错误率监控（同一个 traceId 的失败率）
- 调用链分析（可视化调用关系）

## 注意事项

1. **异步调用**: 如果使用 `@Async` 或线程池，需要手动传递 MDC 上下文：
   ```java
   Map<String, String> mdcContext = MDC.getCopyOfContextMap();
   executor.submit(() -> {
       MDC.setContextMap(mdcContext);
       // 业务逻辑
       MDC.clear();
   });
   ```

2. **性能影响**: 链路追踪拦截器的性能开销极小（仅读取 MDC 和设置请求头），可以放心使用。

3. **日志级别**: 建议在生产环境使用 INFO 级别，避免大量 DEBUG 日志影响性能。

## 总结

通过为 `internal-api-starter` 增强链路追踪能力，实现了：

✅ **自动传播** - traceId 和 spanId 自动传递到下游服务  
✅ **零侵入** - 业务代码无需修改  
✅ **易调试** - 详细的日志记录  
✅ **可扩展** - 支持自定义和集成 APM 工具  

这为构建可观测的微服务架构提供了坚实的基础。
